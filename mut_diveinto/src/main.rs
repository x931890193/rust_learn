fn main() {
    
    /*
    * 由于个人水平和精力有限，难免有谬误，望请大家海涵指正。
    *不要觉得知识点浅显就小看它，有些东西必须深挖搞懂，如此方可写出清晰严谨的代码！
    *  本文就是要深挖不同位置上mut的明确含义。
     */
    //Case1:
    println!("Case1:--------------------------------------");
    //owner是所有者，变量名owner左边的mut表示：（1）owner变量本身可变，即可以再次被赋予其他值。 （2）owner所拥有的String对象（内存区域）本身是可变的，即可以被修改。
    let mut owner = String::from("hello");

    //看， sowner所拥有的String对象可以被修改吧，比如加入其他字符串。
    owner.push_str("world");
    println!("{}",owner);

    //看，owner 变量被重新赋值，现在拥有一个新的String对象，这都是owner变量左侧的mut赋予它的权力。
    owner = String::from("a other string object");
    println!("{}",owner);

    //一个对象（内存区域）是否可变，即可被修改， 完全由其“所有者”决定！
    let mut xa: [i32;5] = [1,2,3,4,5];
    let  ya: [i32;5] = [6,7,8,9,10];

    xa[0] = 11;
    println!("{:?}", xa);

    //ya[0] = 12; 报错：因为ya不可变。

    //注意看下面: ya将自己所拥有的数组对象的所有权转移给了xa, 
    xa = ya;

    //注意只有所有者才能决定其所拥有的对象（内存区域）是否可变，即是否可修改！即变量名左侧的mut是关键。
    xa[0] = 20;
    println!("{:?}", xa);

    //Case2:
    println!("Case2:--------------------------------------");
    //v是所有者，它和Case1一样，具备同样权力。
    let mut v:[i32;3] = [1,2,3];
    {

        let mut  borrower:&mut [i32;3] = &mut v; //v 左侧的mut是不是感觉多余呢？因为borrower的类型定义已经很清楚了，何必画蛇添足？ 
        //其实不然，对于稍微大一些的项目而言， 变量和函数的定义未必就在你的眼前， 所以赋值和传参时的冗余信息就非常有必要了，令你不必跳来跳去就可以清楚参数类型和意图。

        //注意：此时的borrower只是一个引用（相当于c的一个数组指针而已），而非slice（胖指针），
        //只是在函数调用传参数时，rust帮我们自动转换成slice而已。
        mut_slice(borrower);
        println!("{:?}", borrower);

        //borrower右侧的mut说明其借来（指向）的对象本身是可变的，即允许修改。
        borrower[0] = 11;
        println!("{:?}", borrower);

        //borrower左侧的mut说明其可以被再次赋予其他值， 即可变。
        let  mut vv: [i32;3] = [4,5,6];
        borrower = &mut vv;
        println!("{:?}", borrower);
    }

    mut_slice(&mut v); //v左侧的mut明确表达这是可变参数，而不必查阅函数定义。
    

}

//接受一个slice（胖指针）作为参数
fn mut_slice(a: &mut [i32]){
    a[2]=5;
}

/*
* 补充知识点：
*  1.  对数组的借用可以产生一个数组切片,  比如上面的: &mut v
*  2. 数组切片slice只是对数组的借用，没有所有权，切记。
*  3. 数组切片slice是”胖指针“,包括: 数组头元素指针和slice长度。
*  4. 数组是编译期大小确定的类型.
*  5. 把数组作为参数传给函数，这个数组不会退化为一个指针，而是会完整复制这个数组，所以函数体内对实参数组的修改，不会影响到外边的数组！切记这和c/c++不同。
*  6. 数组索引类型: usize
*  7. 现在rust编译器规定：对于局部变量/函数参数和返回值等处的类型大小必须为编译期已知量，所以对于”动态大小类型“，即DST , 一般不允许直接创建， 必须通过指针间接创建和操作，比如：&, Box等。
*  8. 元素类型 和数组长度都相同，才是相同类型的数组。
*  9.  rust规定严格， 不同类型通常禁止隐士自动转换， 必须手动显示转换。
*  10. 调试时，想知道某个变量，参数等的实际类型， 可以令rust编译器报错给出，比如类型不匹配时， rust编译器会告诉你期望的类型和实际的类型。
 */